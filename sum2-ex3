; Project 2: Arithmetic using the Assembly Language
    .global main
; Offset that updates the pointer when assigning values to RAM
OS   .EQU 0x04
ITER .EQU 10 ; Counter in decimal

main
; Starting from 0x2000.0000
    MOVW R0, #0x0000
    MOVT R0, #0x2000
; Store 20 random values (not really random)
    MOVW R1, #0x01FF
    MOVT R1, #0x0302
    STR R1, [R0]
    MOVW R1, #0x0504
    MOVT R1, #0x0706
    STR R1, [R0, #OS]!
    MOVW R1, #0x0908
    MOVT R1, #0x0B0A
    STR R1, [R0, #OS]!
    MOVW R1, #0x0D0C
    MOVT R1, #0x0F0E
    STR R1, [R0, #OS]!
    MOVW R1, #0x1110
    MOVT R1, #0x1312
	STR R1, [R0, #OS]!


; Starting point where we can take values from [X_i]
    MOVW R0, #0xFFFF ;[2000.0000 - 1] = 1FFF.FFFF
    MOVT R0, #0x1FFF

; R12 points to [Y_0] i.e. [2000.000A] minus one
    MOVW R12, #0x0009 ;[2000.000A - 1] = 2000.0009
    MOVT R12, #0x2000

    MOV R10, #0

    MOVW R1, #0x001C; [20-4 = 1C]
    MOVT R1, #0x2000

; Second sum, exercise three
SUM2_EX3
    LDRB R1, [R0, #1]!;  R1 = X_i; [0 =< i =< 4]
    LDRB R2, [R12, #1]!; R1 = X_i; [0 =< i =< 4]
    ADDS R2, R1; Store the updated result in R3
	ADDS R3, R2; Step needed
    ADD  R10, R10, #1 ; Start with the first iteration
    CMP R10, #4 ; Make sure to do this 10x

    BNE SUM2_EX3 ; While not equal, go back and sum again

    MOVW R1, #0x0024; [28-4 = 24] bc its the third exercise
    MOVT R1, #0x2000
    STR R3, [R1, #4]!

fin B fin

    .end







